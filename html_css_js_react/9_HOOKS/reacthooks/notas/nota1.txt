- useState:
um dos principais hooks cuja funções é gerenciar valores, podendo consultar e alterar const [fruta, setFruta] = useState(""). O Hook permite re-renderizar um componente em tempo real sem dar reload na página, o que não ocorre na manipulação de variáveis

- useReducer
parecido com o usaState com o diferencial de poder executar uma função na manipulação do conteúdo. Ele recebe um valor para gerenciar e uma função para alteração do valor. "O useReducer funciona como um reducer do Redux: você define uma função que recebe o estado atual e uma ação, e retorna o novo estado."

const [state, dispatch] = useReducer(reducer, initialState);

state: o estado atual
dispatch: função para enviar ações
reducer: função que define como o estado muda
initialState: estado inicial

// contador simples
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Contador: {state.count}</p>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
    </div>
  );
}

reducer define como o estado muda com base na ação.
dispatch({ type: 'increment' }) envia uma ação para o reducer.
O estado é atualizado e o componente re-renderiza.

// formulário com múltiplos campos
const initialState = {
  name: '',
  email: '',
};

function reducer(state, action) {
  switch (action.type) {
    case 'updateField':
      return {
        ...state,
        [action.field]: action.value,
      };
    default:
      return state;
  }
}

function Form() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <form>
      <input
        type="text"
        placeholder="Nome"
        value={state.name}
        onChange={(e) =>
          dispatch({ type: 'updateField', field: 'name', value: e.target.value })
        }
      />
      <input
        type="email"
        placeholder="Email"
        value={state.email}
        onChange={(e) =>
          dispatch({ type: 'updateField', field: 'email', value: e.target.value })
        }
      />
      <p>Nome: {state.name}</p>
      <p>Email: {state.email}</p>
    </form>
  );
}

- useEffect
usado para fazer alterações nos elementos ou requisições http, ações que podem ser controladas. O  array de dependências possui os itens a serem monitorados. Usado para executar efeitos colatereais em componentes funcionais, como: buscar dados, agendar eventos ou sincronizar com APIs externas. É um hook que executa uma função depois que o componente renderiza.

useEffect(() => {
  // código que será executado após a renderização
}, [dependências]);

// uma execução
import React, { useEffect } from 'react';

function Hello() {
  useEffect(() => {
    console.log('Componente montado!');
  }, []); // array vazio = executa só uma vez

  return <h1>Olá, mundo!</h1>;
}

//executando quando o estado muda
import React, { useState, useEffect } from 'react';

function Contador() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`O contador mudou para: ${count}`);
  }, [count]); // executa toda vez que "count" muda

  return (
    <div>
      <p>Contador: {count}</p>
      <button onClick={() => setCount(count + 1)}>Incrementar</button>
    </div>
  );
}

// limpeza
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Executando...');
  }, 1000);

  return () => {
    clearInterval(timer); // limpa o intervalo ao desmontar
    console.log('Componente desmontado!');
  };
}, []);

O useEffect sempre roda após a renderização.
Se você não passar o array de dependências, ele roda a cada render.
Se passar [], roda só uma vez.
Se passar [variável], roda quando a variável mudar.
O retorno da função (return () => {}) é usado para limpar efeitos.

Sempre trate erros com try/catch para evitar falhas silenciosas.
Use carregando para mostrar um spinner ou mensagem enquanto os dados chegam.
O array de dependências [] garante que a busca só aconteça uma vez, ao montar o componente.

- useContext
O useContext é um hook do React que permite compartilhar dados entre componentes sem precisar passar props manualmente em cada nível da árvore. ele é próprio para coisas como temas, autenticação, idioma, ou qualquer estado global.

Você cria um Contexto com React.createContext.
Usa um Provider para envolver os componentes que vão consumir esse contexto.
Dentro desses componentes, usa useContext para acessar os dados.

//tema

1 createContext
import React, { createContext, useState } from 'react';

export const TemaContexto = createContext();

export function TemaProvider({ children }) {
  const [tema, setTema] = useState('claro');

  const alternarTema = () => {
    setTema((prev) => (prev === 'claro' ? 'escuro' : 'claro'));
  };

  return (
    <TemaContexto.Provider value={{ tema, alternarTema }}>
      {children}
    </TemaContexto.Provider>
  );
}

2 useContext

import React, { useContext } from 'react';
import { TemaContexto } from './TemaProvider';

function BotaoTema() {
  const { tema, alternarTema } = useContext(TemaContexto);

  return (
    <button onClick={alternarTema}>
      Tema atual: {tema} (clique para mudar)
    </button>
  );
}

// envolvendo a aplicação com provider
import React from 'react';
import ReactDOM from 'react-dom';
import { TemaProvider } from './TemaProvider';
import BotaoTema from './BotaoTema';

ReactDOM.render(
  <TemaProvider>
    <BotaoTema />
  </TemaProvider>,
  document.getElementById('root')
);







