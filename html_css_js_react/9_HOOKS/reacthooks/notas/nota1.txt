- useState:
um dos principais hooks cuja fun√ß√µes √© gerenciar valores, podendo consultar e alterar const [fruta, setFruta] = useState(""). O Hook permite re-renderizar um componente em tempo real sem dar reload na p√°gina, o que n√£o ocorre na manipula√ß√£o de vari√°veis

- useReducer
parecido com o usaState com o diferencial de poder executar uma fun√ß√£o na manipula√ß√£o do conte√∫do. Ele recebe um valor para gerenciar e uma fun√ß√£o para altera√ß√£o do valor. "O useReducer funciona como um reducer do Redux: voc√™ define uma fun√ß√£o que recebe o estado atual e uma a√ß√£o, e retorna o novo estado."

const [state, dispatch] = useReducer(reducer, initialState);

state: o estado atual
dispatch: fun√ß√£o para enviar a√ß√µes
reducer: fun√ß√£o que define como o estado muda
initialState: estado inicial

// contador simples
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Contador: {state.count}</p>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
    </div>
  );
}

reducer define como o estado muda com base na a√ß√£o.
dispatch({ type: 'increment' }) envia uma a√ß√£o para o reducer.
O estado √© atualizado e o componente re-renderiza.

// formul√°rio com m√∫ltiplos campos
const initialState = {
  name: '',
  email: '',
};

function reducer(state, action) {
  switch (action.type) {
    case 'updateField':
      return {
        ...state,
        [action.field]: action.value,
      };
    default:
      return state;
  }
}

function Form() {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <form>
      <input
        type="text"
        placeholder="Nome"
        value={state.name}
        onChange={(e) =>
          dispatch({ type: 'updateField', field: 'name', value: e.target.value })
        }
      />
      <input
        type="email"
        placeholder="Email"
        value={state.email}
        onChange={(e) =>
          dispatch({ type: 'updateField', field: 'email', value: e.target.value })
        }
      />
      <p>Nome: {state.name}</p>
      <p>Email: {state.email}</p>
    </form>
  );
}

- useEffect
usado para fazer altera√ß√µes nos elementos ou requisi√ß√µes http, a√ß√µes que podem ser controladas. O  array de depend√™ncias possui os itens a serem monitorados. Usado para executar efeitos colatereais em componentes funcionais, como: buscar dados, agendar eventos ou sincronizar com APIs externas. √â um hook que executa uma fun√ß√£o depois que o componente renderiza.

useEffect(() => {
  // c√≥digo que ser√° executado ap√≥s a renderiza√ß√£o
}, [depend√™ncias]);

// uma execu√ß√£o
import React, { useEffect } from 'react';

function Hello() {
  useEffect(() => {
    console.log('Componente montado!');
  }, []); // array vazio = executa s√≥ uma vez

  return <h1>Ol√°, mundo!</h1>;
}

//executando quando o estado muda
import React, { useState, useEffect } from 'react';

function Contador() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(`O contador mudou para: ${count}`);
  }, [count]); // executa toda vez que "count" muda

  return (
    <div>
      <p>Contador: {count}</p>
      <button onClick={() => setCount(count + 1)}>Incrementar</button>
    </div>
  );
}

// limpeza
useEffect(() => {
  const timer = setInterval(() => {
    console.log('Executando...');
  }, 1000);

  return () => {
    clearInterval(timer); // limpa o intervalo ao desmontar
    console.log('Componente desmontado!');
  };
}, []);

O useEffect sempre roda ap√≥s a renderiza√ß√£o.
Se voc√™ n√£o passar o array de depend√™ncias, ele roda a cada render.
Se passar [], roda s√≥ uma vez.
Se passar [vari√°vel], roda quando a vari√°vel mudar.
O retorno da fun√ß√£o (return () => {}) √© usado para limpar efeitos.

Sempre trate erros com try/catch para evitar falhas silenciosas.
Use carregando para mostrar um spinner ou mensagem enquanto os dados chegam.
O array de depend√™ncias [] garante que a busca s√≥ aconte√ßa uma vez, ao montar o componente.

- useContext
O useContext √© um hook do React que permite compartilhar dados entre componentes sem precisar passar props manualmente em cada n√≠vel da √°rvore. ele √© pr√≥prio para coisas como temas, autentica√ß√£o, idioma, ou qualquer estado global.

Voc√™ cria um Contexto com React.createContext.
Usa um Provider para envolver os componentes que v√£o consumir esse contexto.
Dentro desses componentes, usa useContext para acessar os dados.

//tema

1 createContext
import React, { createContext, useState } from 'react';

export const TemaContexto = createContext();

export function TemaProvider({ children }) {
  const [tema, setTema] = useState('claro');

  const alternarTema = () => {
    setTema((prev) => (prev === 'claro' ? 'escuro' : 'claro'));
  };

  return (
    <TemaContexto.Provider value={{ tema, alternarTema }}>
      {children}
    </TemaContexto.Provider>
  );
}

2 useContext

import React, { useContext } from 'react';
import { TemaContexto } from './TemaProvider';

function BotaoTema() {
  const { tema, alternarTema } = useContext(TemaContexto);

  return (
    <button onClick={alternarTema}>
      Tema atual: {tema} (clique para mudar)
    </button>
  );
}

// envolvendo a aplica√ß√£o com provider
import React from 'react';
import ReactDOM from 'react-dom';
import { TemaProvider } from './TemaProvider';
import BotaoTema from './BotaoTema';

ReactDOM.render(
  <TemaProvider>
    <BotaoTema />
  </TemaProvider>,
  document.getElementById('root')
);

- useRef
  um hook importante que serve para armazenar valores mut√°veis que n√£o causam re-rendiriza√ß√£o quando mudam. Tamb√©m √© muito usado para acessar diretamente elementos dom.
  O use ref retorna um objeto com a propriedade .current. Esse objeto se mant√©m entre renderiza√ß√µes e n√£o dispara re-render quando seu valor √© alterado

const myRef = useRef(initialState)

// 1 - Refer√™ncia a elemento dom
ideal para manipular elementos diretamente, como focar um input ou medir dimens√µes.

import { useRef, useEffect } from 'react';

function Formulario() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current.focus(); // foca o input ao montar
  }, []);

  return <input ref={inputRef} placeholder="Digite algo" />;
}

// 2 - armazenar valores mut√°veis sem re-render
  √ötil para guardar valores entre renderiza√ß√µes sem afetar o ciclo de render.

function Temporizador() {
  const contador = useRef(0);

  const incrementar = () => {
    contador.current += 1;
    console.log('Contador:', contador.current);
  };

  return <button onClick={incrementar}>Incrementar</button>;
}

// 3 - guardar valores anteriores
  podendo comparar valores entre renderiza√ß√µes

import { useEffect, useRef } from 'react';

function ValorAnterior({ valor }) {
  const valorAnterior = useRef();

  useEffect(() => {
    valorAnterior.current = valor;
  }, [valor]);

  return (
    <div>
      <p>Valor atual: {valor}</p>
      <p>Valor anterior: {valorAnterior.current}</p>
    </div>
  );
}

üìå Quando usar useRef?

Use useRef quando:

    Precisa acessar ou manipular elementos DOM diretamente.

    Quer armazenar valores mut√°veis que n√£o devem causar re-render.

    Precisa persistir dados entre renderiza√ß√µes sem afetar o estado da UI.

    Est√° lidando com setInterval, setTimeout ou WebSocket, e quer manter uma refer√™ncia est√°vel.







